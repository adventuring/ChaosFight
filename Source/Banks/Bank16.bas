          rem ChaosFight - Source/Banks/Bank16.bas
          rem Copyright Â© 2025 Interworldly Adventuring, LLC.

          bank 16
          
          rem Music system - dedicated 3.5kiB bank for compiled samples
          #include "Source/Routines/MusicSystem.bas"
          
          rem =================================================================
          rem SONGS BANK HELPER FUNCTIONS
          rem =================================================================
          rem These functions access song data tables and streams in this bank
          rem =================================================================
          
          rem Song pointer lookup tables (will be generated by Makefile)
          rem Format: data SongPointersL, SongPointersH tables (256 entries each)
          rem Placeholder tables until generated
          data SongPointersL
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          end
          data SongPointersH
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          end
          
          rem Voice 1 stream offset table (bytes from Voice0 start to Voice1 start)
          rem Will be calculated when songs are generated
          data SongVoice1Offsets
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
          end
          
          rem Lookup song pointer from tables
          rem Input: temp1 = song ID (0-255)
          rem Output: SongPointerL, SongPointerH = pointer to Song_Voice0 stream
LoadSongPointer
          rem Use array access to lookup pointer
          let SongPointerL = SongPointersL[temp1]
          let SongPointerH = SongPointersH[temp1]
          return
          
          rem Calculate Voice 1 pointer from Voice 0 pointer + offset
          rem Input: temp1 = song ID, SongPointerL/H already set (Voice 0 pointer)
          rem Output: SongPointerL/H = Voice 1 pointer
LoadSongVoice1Pointer
          rem Get Voice 1 offset from table (temp1 still contains song ID from LoadSongPointer)
          let temp2 = SongVoice1Offsets[temp1]
          rem Add offset to Voice 0 pointer (16-bit addition)
          let temp3 = SongPointerL
          let SongPointerL = temp3 + temp2
          rem Handle carry
          if SongPointerL < temp3 then let SongPointerH = SongPointerH + 1
          rem Note: For songs with Voice1 stream longer than 255 bytes, need high byte offset too
          rem TODO: Add high byte offset table if needed for songs > 255 bytes per voice
          return
          
          rem Load next note from Voice 0 stream using assembly for pointer access
          rem Input: MusicVoice0PointerL/H points to current note in Song_Voice0 stream
          rem Output: Updates TIA registers, advances pointer, sets MusicVoice0Frame
LoadMusicNote0
          asm
          ; Load 4 bytes from stream[pointer]
          ldy #0
          lda (MusicVoice0PointerL),y  ; Load AUDCV
          sta temp2
          iny
          lda (MusicVoice0PointerL),y  ; Load AUDF
          sta temp3
          iny
          lda (MusicVoice0PointerL),y  ; Load Duration
          sta temp4
          iny
          lda (MusicVoice0PointerL),y  ; Load Delay
          sta temp5
          end
          
          rem Check for end of track (Duration = 0)
          if temp4 = 0 then MusicVoice0PointerH = 0 : AUDV0 = 0 : return
          
          rem Extract AUDC (upper 4 bits) and AUDV (lower 4 bits) from AUDCV
          temp6 = temp2 & %11110000
          temp6 = temp6 / 16
          temp7 = temp2 & %00001111
          
          rem Write to TIA registers
          AUDC0 = temp6
          AUDF0 = temp3
          AUDV0 = temp7
          
          rem Set frame counter = Duration + Delay
          let MusicVoice0Frame = temp4 + temp5
          
          rem Advance pointer by 4 bytes (16-bit addition)
          let temp2 = MusicVoice0PointerL
          let MusicVoice0PointerL = temp2 + 4
          if MusicVoice0PointerL < temp2 then let MusicVoice0PointerH = MusicVoice0PointerH + 1
          
          return
          
          rem Load next note from Voice 1 stream
LoadMusicNote1
          asm
          ; Load 4 bytes from stream[pointer]
          ldy #0
          lda (MusicVoice1PointerL),y  ; Load AUDCV
          sta temp2
          iny
          lda (MusicVoice1PointerL),y  ; Load AUDF
          sta temp3
          iny
          lda (MusicVoice1PointerL),y  ; Load Duration
          sta temp4
          iny
          lda (MusicVoice1PointerL),y  ; Load Delay
          sta temp5
          end
          
          rem Check for end of track (Duration = 0)
          if temp4 = 0 then MusicVoice1PointerH = 0 : AUDV1 = 0 : return
          
          rem Extract AUDC and AUDV
          temp6 = temp2 & %11110000
          temp6 = temp6 / 16
          temp7 = temp2 & %00001111
          
          rem Write to TIA registers (Voice 1)
          AUDC1 = temp6
          AUDF1 = temp3
          AUDV1 = temp7
          
          rem Set frame counter = Duration + Delay
          MusicVoice1Frame = temp4 + temp5
          
          rem Advance pointer by 4 bytes
          temp2 = MusicVoice1PointerL
          MusicVoice1PointerL = temp2 + 4
          if MusicVoice1PointerL < temp2 then MusicVoice1PointerH = MusicVoice1PointerH + 1
          
          return