;;; ChaosFight - Source/Routines/MainLoop.bas
;;; Copyright © 2025 Bruce-Robert Pocock.


MainLoop .proc
          ;; Dispatches game modes and handles reset entry point
          ;; Returns: NEVER (infinite loop - loops forever via MainLoopContinue → MainLoopDrawScreen → MainLoop)
          ;; Inputs: switchreset (hardware), gameMode (global 0-7)
          ;; Outputs: Dispatches to mode-specific handlers
          ;; Mutates: None; dispatcher only
          ;; Calls: WarmStart bank12, PublisherPreludeMain bank14, AuthorPrelude bank14,
          ;; TitleScreenMain bank14, CharacterSelectInputEntry bank9,
          ;; FallingAnimation1 bank11, ArenaSelect1 bank14,
          ;; GameMainLoop bank11, WinnerAnnouncementLoop bank12,
          ;; PlayMusic bank1, titledrawscreen bank9
          ;; Constraints: Must remain colocated with MainLoopDrawScreen
          ;; CRITICAL: MainLoop is an infinite loop. It is entered via direct jump from WarmStart
          ;; (no stack push). It loops forever and never returns.

          ;; Entry point for entire game loop
          ;; STACK PICTURE: [] (empty - MainLoop entered via direct jump from WarmStart, no stack push)
          ;; Increment frame counter (used for frame budgeting and timing)
          inc frame
          ;; CRITICAL: Skip reset check on first frame after cold start to prevent stack overflow
          ;; During cold start, switchreset may read as true, causing WarmStart to be called
          ;; before the stack is fully initialized, leading to stack overflow
          ;; Skip reset check when frame = 1 (first frame after cold start)
          lda frame
          cmp # 1
          beq SkipResetCheck

          ;; Check if reset switch is pressed (SWCHB bit 0: 0 = pressed, 1 = not pressed)
          ;; SWCHB = $0282 (RIOT port B - switches)
          ;; STACK PICTURE: [] (empty)
          lda $0282
          and # 1
          bne SkipResetCheck

          ;; Bit 0 = 1 means reset not pressed, skip
          ;; Reset switch pressed - jump to WarmStart
          ;; Jump to WarmStart in bank 12 without pushing to stack (WarmStart will eventually call MainLoop again)
          ;; STACK PICTURE: [] (empty - no bytes pushed)
          ldx # 12                         ;;; Bank 12 = $ffe0 + 12, 0-based = 12
          nop $ffe0, x                     ;;; Switch to bank 12
          jmp WarmStart                    ;;; Jump directly to WarmStart (no stack push)

SkipResetCheck:
          ;; STACK PICTURE: [] (empty)

          ;; Execution falls through to continue

          ;; Optimized: Use on/cross-bank call to for space efficiency
          ;; on gameMode cross-bank call to uses rts to jump to target, returns to ongosub0 (generated by batariBASIC)
          ;; STACK PICTURE: [] (empty)
          jsr MainLoopModePublisherPrelude
          ;; STACK PICTURE: [] (empty - jsr pushed 2 bytes, rts popped 2 bytes, net zero change)
          ;; Execution continues at ongosub0 label (generated by batariBASIC after jump tables)
          ;; CRITICAL: MainLoop is an infinite loop - it should NEVER return!
          ;; After handling one frame, it loops back to MainLoopContinue (via MainLoopDrawScreen)
          ;; STACK PICTURE: [] (empty)
          jmp MainLoopContinue

          ;; TODO: #1303 CRITICAL FIX: ongosub0 is at same address as MainLoopModePublisherPrelude, causing fall-through
          ; We need to add explicit jump here to prevent fall-through into handlers
          ; This will be placed at ongosub0 by the assembler
MainLoopContinue:
          ;; Routes audio updates after per-mode execution
          ;; CRITICAL: PlayMusic is called from Vblank handlers (earlier in frame) to reduce stack depth
          ;; Modes < 3 and mode 7 handle music in VblankMode handlers (VblankHandlers.bas)
          ;; This avoids stack overflow by calling PlayMusic when stack is shallower
          ;; STACK PICTURE: [] (empty)
          ;; (tail call to MainLoopDrawScreen preserves stack)
          jmp MainLoopDrawScreen

.pend

MainLoopModePublisherPrelude .proc
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModePublisherPrelude)
          ;; on gameMode cross-bank call to pushes normal return address, then JMPs to target
          ;; cross-bank call to PublisherPreludeMain bank14 is a far call (pushes 4-byte encoded return)
          ;; When PublisherPreludeMain returns with return otherbank, it pops 2 bytes from encoded return
          ;; This leaves the 2-byte normal return address from on gameMode cross-bank call to on the sta

          ;; So we must use return thisbank (RTS) to pop that 2-byte normal address
          ;; Cross-bank call to PublisherPreludeMain in bank 14
          lda # >(AfterPublisherPreludeMain-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterPublisherPreludeMain hi]
          lda # <(AfterPublisherPreludeMain-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterPublisherPreludeMain hi] [SP+0: AfterPublisherPreludeMain lo]
          lda # >(PublisherPreludeMain-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterPublisherPreludeMain hi] [SP+1: AfterPublisherPreludeMain lo] [SP+0: PublisherPreludeMain hi]
          lda # <(PublisherPreludeMain-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterPublisherPreludeMain hi] [SP+2: AfterPublisherPreludeMain lo] [SP+1: PublisherPreludeMain hi] [SP+0: PublisherPreludeMain lo]
                    ldx # 13
          jmp BS_jsr
AfterPublisherPreludeMain:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

.pend

MainLoopModeAuthorPrelude .proc
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModeAuthorPrelude)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to AuthorPrelude in bank 14
          lda # >(AfterAuthorPrelude-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterAuthorPrelude hi]
          lda # <(AfterAuthorPrelude-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterAuthorPrelude hi] [SP+0: AfterAuthorPrelude lo]
          lda # >(AuthorPrelude-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterAuthorPrelude hi] [SP+1: AfterAuthorPrelude lo] [SP+0: AuthorPrelude hi]
          lda # <(AuthorPrelude-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterAuthorPrelude hi] [SP+2: AfterAuthorPrelude lo] [SP+1: AuthorPrelude hi] [SP+0: AuthorPrelude lo]
                    ldx # 13
          jmp BS_jsr
AfterAuthorPrelude:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

.pend

MainLoopModeTitleScreen .proc
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModeTitleScreen)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to TitleScreenMain in bank 14
          lda # >(AfterTitleScreenMain-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterTitleScreenMain hi]
          lda # <(AfterTitleScreenMain-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterTitleScreenMain hi] [SP+0: AfterTitleScreenMain lo]
          lda # >(TitleScreenMain-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterTitleScreenMain hi] [SP+1: AfterTitleScreenMain lo] [SP+0: TitleScreenMain hi]
          lda # <(TitleScreenMain-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterTitleScreenMain hi] [SP+2: AfterTitleScreenMain lo] [SP+1: TitleScreenMain hi] [SP+0: TitleScreenMain lo]
                    ldx # 13
          jmp BS_jsr
AfterTitleScreenMain:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

.pend

MainLoopModeCharacterSelect .proc
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModeCharacterSelect)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to CharacterSelectInputEntry in bank 9
          lda # >(AfterCharacterSelectInputEntry-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterCharacterSelectInputEntry hi]
          lda # <(AfterCharacterSelectInputEntry-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterCharacterSelectInputEntry hi] [SP+0: AfterCharacterSelectInputEntry lo]
          lda # >(CharacterSelectInputEntry-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterCharacterSelectInputEntry hi] [SP+1: AfterCharacterSelectInputEntry lo] [SP+0: CharacterSelectInputEntry hi]
          lda # <(CharacterSelectInputEntry-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterCharacterSelectInputEntry hi] [SP+2: AfterCharacterSelectInputEntry lo] [SP+1: CharacterSelectInputEntry hi] [SP+0: CharacterSelectInputEntry lo]
                    ldx # 8
          jmp BS_jsr
AfterCharacterSelectInputEntry:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

MainLoopModeFallingAnimation
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModeFallingAnimation)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to FallingAnimation1 in bank 11
          lda # >(AfterFallingAnimation1-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterFallingAnimation1 hi]
          lda # <(AfterFallingAnimation1-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterFallingAnimation1 hi] [SP+0: AfterFallingAnimation1 lo]
          lda # >(FallingAnimation1-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterFallingAnimation1 hi] [SP+1: AfterFallingAnimation1 lo] [SP+0: FallingAnimation1 hi]
          lda # <(FallingAnimation1-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterFallingAnimation1 hi] [SP+2: AfterFallingAnimation1 lo] [SP+1: FallingAnimation1 hi] [SP+0: FallingAnimation1 lo]
                    ldx # 10
          jmp BS_jsr
AfterFallingAnimation1:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

.pend

MainLoopModeArenaSelect .proc
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModeArenaSelect)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to ArenaSelect1 in bank 14
          lda # >(AfterArenaSelect1-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterArenaSelect1 hi]
          lda # <(AfterArenaSelect1-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterArenaSelect1 hi] [SP+0: AfterArenaSelect1 lo]
          lda # >(ArenaSelect1-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterArenaSelect1 hi] [SP+1: AfterArenaSelect1 lo] [SP+0: ArenaSelect1 hi]
          lda # <(ArenaSelect1-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterArenaSelect1 hi] [SP+2: AfterArenaSelect1 lo] [SP+1: ArenaSelect1 hi] [SP+0: ArenaSelect1 lo]
                    ldx # 13
          jmp BS_jsr
AfterArenaSelect1:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

.pend

MainLoopModeGameMain .proc
          ;; CRITICAL: Guard against being called when not in game mode
          ;; Returns: Near (return thisbank)
          ;; This prevents crashes when gameMode is corrupted or incorrectly set
          ;; Only call GameMainLoop when actually in game mode (ModeGame = 6)
          lda gameMode
          cmp ModeGame
          bne MainLoopModeDispatch
          jmp MainLoopModeGameMainContinue
MainLoopModeDispatch:


          rts

MainLoopModeGameMainContinue
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to GameMainLoop in bank 11
          lda # >(AfterGameMainLoop-1)
          pha
          lda # <(AfterGameMainLoop-1)
          pha
          lda # >(GameMainLoop-1)
          pha
          lda # <(GameMainLoop-1)
          pha
                    ldx # 10
          jmp BS_jsr
AfterGameMainLoop:


          rts

.pend

MainLoopModeWinnerAnnouncement .proc
          ;; CRITICAL: on gameMode cross-bank call to is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (from jsr MainLoopModeWinnerAnnouncement)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to WinnerAnnouncementLoop in bank 12
          lda # >(AfterWinnerAnnouncementLoop-1)
          pha
          ;; STACK PICTURE: [SP+2: MainLoop ret hi] [SP+1: MainLoop ret lo] [SP+0: AfterWinnerAnnouncementLoop hi]
          lda # <(AfterWinnerAnnouncementLoop-1)
          pha
          ;; STACK PICTURE: [SP+3: MainLoop ret hi] [SP+2: MainLoop ret lo] [SP+1: AfterWinnerAnnouncementLoop hi] [SP+0: AfterWinnerAnnouncementLoop lo]
          lda # >(WinnerAnnouncementLoop-1)
          pha
          ;; STACK PICTURE: [SP+4: MainLoop ret hi] [SP+3: MainLoop ret lo] [SP+2: AfterWinnerAnnouncementLoop hi] [SP+1: AfterWinnerAnnouncementLoop lo] [SP+0: WinnerAnnouncementLoop hi]
          lda # <(WinnerAnnouncementLoop-1)
          pha
          ;; STACK PICTURE: [SP+5: MainLoop ret hi] [SP+4: MainLoop ret lo] [SP+3: AfterWinnerAnnouncementLoop hi] [SP+2: AfterWinnerAnnouncementLoop lo] [SP+1: WinnerAnnouncementLoop hi] [SP+0: WinnerAnnouncementLoop lo]
                    ldx # 11
          jmp BS_jsr
AfterWinnerAnnouncementLoop:
          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (BS_return consumed 4 bytes, left 2-byte near return)


          ;; STACK PICTURE: [SP+1: MainLoop ret hi] [SP+0: MainLoop ret lo] (RTS will pop 2 bytes)
          rts

.pend

SkipMusicUpdate .proc
.pend

MainLoopDrawScreen .proc
          ;; Renders the appropriate screen for the current game mode
          ;; Returns: NEVER (loops back to MainLoop - infinite loop)
          ;; Inputs: gameMode (global 0-7)
          ;; Outputs: Screen rendered via titledrawscreen or drawscreen
          ;; Mutates: TIA registers, playfield, sprite sta

          ;; Calls: titledrawscreen bank9 (title screens); colocated with MainLoop
          ;; Notes: Modes 3-6 funnel through mode-specific draw logic
          ;; CRITICAL: MainLoopDrawScreen is part of the infinite MainLoop cycle
          ;; It loops back to MainLoop, never returning

          ;; Titlescreen graphics and kernel reside in bank9
          ;; Cross-bank call to DrawTitleScreen in bank 9
          ;; STACK PICTURE: [] (empty)
          lda # >(AfterDrawTitleScreen-1)
          pha
          ;; STACK PICTURE: [SP+0: AfterDrawTitleScreen hi]
          lda # <(AfterDrawTitleScreen-1)
          pha
          ;; STACK PICTURE: [SP+1: AfterDrawTitleScreen hi] [SP+0: AfterDrawTitleScreen lo]
          lda # >(DrawTitleScreen-1)
          pha
          ;; STACK PICTURE: [SP+2: AfterDrawTitleScreen hi] [SP+1: AfterDrawTitleScreen lo] [SP+0: DrawTitleScreen hi]
          lda # <(DrawTitleScreen-1)
          pha
          ;; STACK PICTURE: [SP+3: AfterDrawTitleScreen hi] [SP+2: AfterDrawTitleScreen lo] [SP+1: DrawTitleScreen hi] [SP+0: DrawTitleScreen lo]
                    ldx # 8
          jmp BS_jsr
AfterDrawTitleScreen:
          ;; STACK PICTURE: [] (empty - BS_return consumed 4 bytes from DrawTitleScreen call)

          ;; CRITICAL: drawscreen must be called every frame
          ;; After DrawTitleScreen bank9 returns via BS_return, we’re back in bank 16
          ;; MainLoopDrawScreen is in bank 16, and drawscreen is also in bank 16
          ;; Use batariBASIC’s drawscreen statement which handles bank context correctly
          ;; If gameMode >= 3, then drawscreen
          lda gameMode
          cmp # 3
          bcc MainLoopSkipDrawScreen
          ;; drawscreen is handled by MainLoopDrawScreen routine
          jmp MainLoopDrawScreen
MainLoopSkipDrawScreen:
          jmp MainLoop

.pend

