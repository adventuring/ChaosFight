;;; ChaosFight - Source/Routines/MainLoop.bas
;;; Copyright © 2025 Bruce-Robert Pocock.


MainLoop .proc
          ;; Dispatches game modes and handles reset entry point
          ;; Returns: Far (return otherbank)
          ;; Inputs: switchreset (hardware), gameMode (global 0-7)
          ;; Outputs: Dispatches to mode-specific handlers
          ;; Mutates: None; dispatcher only
          ;; Calls: WarmStart bank13, PublisherPreludeMain bank14, AuthorPrelude bank14,
          ;; TitleScreenMain bank14, CharacterSelectInputEntry bank9,
          ;; FallingAnimation1 bank11, ArenaSelect1 bank14,
          ;; GameMainLoop bank11, WinnerAnnouncementLoop bank12,
          ;; PlayMusic bank1, titledrawscreen bank9
          ;; Constraints: Must remain colocated with MainLoopDrawScreen

          ;; Entry point for entire game loop
          ;; Increment frame counter (used for frame budgeting and timing)
          inc frame
          ;; CRITICAL: Skip reset check on first frame after cold start to prevent stack overflow
          ;; During cold start, switchreset may read as true, causing WarmStart to be called
          ;; before the stack is fully initialized, leading to stack overflow
          ;; Skip reset check when frame = 1 (first frame after cold start)
          lda frame
          cmp # 1
          beq skip_reset_check

          ;; Check if reset switch is pressed (SWCHB bit 0: 0 = pressed, 1 = not pressed)
          lda SWCHB
          and # 1
          bne skip_reset_check

          ;; Bit 0 = 1 means reset not pressed, skip
          ;; Reset switch pressed - call WarmStart
          ;; Cross-bank call to WarmStart in bank 13
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(WarmStart-1)
          pha
          lda # <(WarmStart-1)
          pha
          ldx # 12
          jmp BS_jsr

return_point:

skip_reset_check:

          ;; TODO: ; fall through to continue

          ;; Optimized: Use on/gosub for space efficiency
          ;; on gameMode gosub uses rts to jump to target, returns to ongosub0 (generated by batariBASIC)
          jsr MainLoopModePublisherPrelude
          ;; TODO: ; Execution continues at ongosub0 label (generated by batariBASIC after jump tables)
          jsr BS_return

          ;; TODO: ; CRITICAL FIX: ongosub0 is at same address as MainLoopModePublisherPrelude, causing fall-through
          ; We need to add explicit jump here to prevent fall-through into handlers
          ; This will be placed at ongosub0 by the assembler
          jmp MainLoopContinue

          ;; Routes audio updates after per-mode execution
          ;; CRITICAL: PlayMusic is called from Vblank handlers (earlier in frame) to reduce stack depth
          ;; Modes < 3 and mode 7 handle music in VblankMode handlers (VblankHandlers.bas)
          ;; This avoids stack overflow by calling PlayMusic when stack is shallower
          jmp MainLoopDrawScreen

.pend

MainLoopModePublisherPrelude .proc
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; on gameMode gosub pushes normal return address, then JMPs to target
          ;; gosub PublisherPreludeMain bank14 is a far call (pushes 4-byte encoded return)
          ;; When PublisherPreludeMain returns with return otherbank, it pops 2 bytes from encoded return
          ;; This leaves the 2-byte normal return address from on gameMode gosub on the sta

          ;; So we must use return thisbank (RTS) to pop that 2-byte normal address
          ;; Cross-bank call to PublisherPreludeMain in bank 14
          lda # >(return_point2-1)
          pha
          lda # <(return_point2-1)
          pha
          lda # >(PublisherPreludeMain-1)
          pha
          lda # <(PublisherPreludeMain-1)
          pha
                    ldx # 13
          jmp BS_jsr
return_point:


          rts

.pend

MainLoopModeAuthorPrelude .proc
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to AuthorPrelude in bank 14
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(AuthorPrelude-1)
          pha
          lda # <(AuthorPrelude-1)
          pha
                    ldx # 13
          jmp BS_jsr
return_point:


          rts

.pend

MainLoopModeTitleScreen .proc
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to TitleScreenMain in bank 14
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(TitleScreenMain-1)
          pha
          lda # <(TitleScreenMain-1)
          pha
                    ldx # 13
          jmp BS_jsr
return_point:


          rts

.pend

MainLoopModeCharacterSelect .proc
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to CharacterSelectInputEntry in bank 9
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(CharacterSelectInputEntry-1)
          pha
          lda # <(CharacterSelectInputEntry-1)
          pha
                    ldx # 8
          jmp BS_jsr
return_point:


          rts

MainLoopModeFallingAnimation
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to FallingAnimation1 in bank 11
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(FallingAnimation1-1)
          pha
          lda # <(FallingAnimation1-1)
          pha
                    ldx # 10
          jmp BS_jsr
return_point:


          rts

.pend

MainLoopModeArenaSelect .proc
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to ArenaSelect1 in bank 14
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(ArenaSelect1-1)
          pha
          lda # <(ArenaSelect1-1)
          pha
                    ldx # 13
          jmp BS_jsr
return_point:


          rts

.pend

MainLoopModeGameMain .proc
          ;; CRITICAL: Guard against being called when not in game mode
          ;; Returns: Near (return thisbank)
          ;; This prevents crashes when gameMode is corrupted or incorrectly set
          ;; Only call GameMainLoop when actually in game mode (ModeGame = 6)
          lda gameMode
          cmp ModeGame
          bne MainLoopModeDispatch
          jmp MainLoopModeGameMainContinue
MainLoopModeDispatch:


          rts

MainLoopModeGameMainContinue
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to GameMainLoop in bank 11
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(GameMainLoop-1)
          pha
          lda # <(GameMainLoop-1)
          pha
                    ldx # 10
          jmp BS_jsr
return_point:


          rts

.pend

MainLoopModeWinnerAnnouncement .proc
          ;; CRITICAL: on gameMode gosub is a NEAR call (pushes normal 2-byte return address)
          ;; Returns: Near (return thisbank)
          ;; Must use return thisbank (RTS) to match the near call
          ;; Cross-bank call to WinnerAnnouncementLoop in bank 12
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(WinnerAnnouncementLoop-1)
          pha
          lda # <(WinnerAnnouncementLoop-1)
          pha
                    ldx # 11
          jmp BS_jsr
return_point:


          rts

.pend

SkipMusicUpdate .proc
.pend

MainLoopDrawScreen .proc
          ;; Renders the appropriate screen for the current game mode
          ;; Returns: Far (return otherbank)
          ;; Inputs: gameMode (global 0-7)
          ;; Outputs: Screen rendered via titledrawscreen or drawscreen
          ;; Mutates: TIA registers, playfield, sprite sta

          ;; Calls: titledrawscreen bank9 (title screens); colocated with MainLoop
          ;; Notes: Modes 3-6 funnel through mode-specific draw logic

          ;; Titlescreen graphics and kernel reside in bank9
          ;; Cross-bank call to DrawTitleScreen in bank 9
          lda # >(return_point-1)
          pha
          lda # <(return_point-1)
          pha
          lda # >(DrawTitleScreen-1)
          pha
          lda # <(DrawTitleScreen-1)
          pha
                    ldx # 8
          jmp BS_jsr
return_point:

          ;; CRITICAL: drawscreen must be called every frame
          ;; After DrawTitleScreen bank9 returns via BS_return, we’re back in bank 16
          ;; MainLoopDrawScreen is in bank 16, and drawscreen is also in bank 16
          ;; Use batariBASIC’s drawscreen statement which handles bank context correctly
                    if gameMode >= 3 then drawscreen
          jmp MainLoop

.pend

